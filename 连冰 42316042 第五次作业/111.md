# 三种算法结果对比分析报告

## 一、性能指标对比

| 算法 | 总距离(km) | 总时间(小时) | 总成本 | 分配率 |
|------|-----------|------------|--------|--------|
| **贪心插入算法** | **20.49** | **0.32** | **108.90** | 100% |
| 最近邻算法 | 32.47 | 1.62 | 194.83 | 100% |
| 优先级算法 | 36.60 | 1.83 | 219.61 | 100% |

### 关键发现：
- ✅ **贪心插入算法在所有指标上都是最优的**
  - 距离最短：20.49km（比最近邻算法少36.9%，比优先级算法少44.0%）
  - 时间最短：0.32小时（比最近邻算法快80.2%，比优先级算法快82.5%）
  - 成本最低：108.90（比最近邻算法低44.1%，比优先级算法低50.4%）

---

## 二、负载分配对比

| 算法 | 骑手0负载 | 骑手1负载 | 骑手2负载 | 负载均衡度 |
|------|----------|----------|----------|-----------|
| **贪心插入算法** | 4.85/6.00 (80.8%) | 0.00/6.00 (0%) | 5.25/6.00 (87.5%) | **不均衡** |
| 最近邻算法 | 5.76/6.00 (96.0%) | 0.77/6.00 (12.8%) | 3.57/6.00 (59.5%) | 不均衡 |
| **优先级算法** | 3.36/6.00 (56.0%) | 3.17/6.00 (52.8%) | 3.57/6.00 (59.5%) | **最均衡** |

### 关键发现：
- ✅ **优先级算法负载最均衡**：三个骑手的负载率都在52.8%-59.5%之间
- ⚠️ **贪心算法负载不均衡**：骑手1完全没有任务（0%），骑手0和2负载较高
- ⚠️ **最近邻算法负载不均衡**：骑手0负载96%（接近满载），骑手1只有12.8%

---

## 三、订单分配对比

| 算法 | 骑手0订单数 | 骑手1订单数 | 骑手2订单数 | 分配特点 |
|------|-----------|-----------|-----------|---------|
| **贪心插入算法** | 4个 | 0个 | 4个 | 集中分配，骑手1闲置 |
| 最近邻算法 | 4个 | 1个 | 3个 | 相对分散 |
| **优先级算法** | 3个 | 2个 | 3个 | **最分散** |

### 关键发现：
- ✅ **优先级算法分配最分散**：三个骑手都有任务，分配相对均匀
- ⚠️ **贪心算法存在资源浪费**：骑手1完全没有被使用

---

## 四、算法特点分析

### 1. 贪心插入算法 (最优性能)

**优势：**
- ✅ 总距离最短（20.49km）
- ✅ 总时间最短（0.32小时）
- ✅ 总成本最低（108.90）
- ✅ 算法考虑插入成本，能找到较优的插入位置

**劣势：**
- ❌ 负载不均衡（骑手1完全闲置）
- ❌ 资源利用率低（3个骑手只用了2个）
- ❌ 可能存在局部最优问题

**适用场景：**
- 追求最低成本和最短距离的场景
- 骑手数量充足，可以接受部分骑手闲置
- 对资源利用率要求不高的场景

---

### 2. 最近邻算法 (中等性能)

**优势：**
- ✅ 实现简单，运行速度快
- ✅ 考虑订单紧急程度（通过加权距离）
- ✅ 所有骑手都有任务分配

**劣势：**
- ❌ 总距离较长（32.47km，比贪心算法多58.5%）
- ❌ 总时间较长（1.62小时，比贪心算法多406%）
- ❌ 总成本较高（194.83，比贪心算法多78.9%）
- ❌ 负载不均衡（骑手0接近满载，骑手1负载很低）
- ❌ 只考虑局部最优（当前位置最近），可能产生较长路径

**适用场景：**
- 需要快速响应的场景
- 订单数量很大，需要快速计算
- 对解质量要求不高的场景

---

### 3. 优先级算法 (负载均衡最优)

**优势：**
- ✅ **负载最均衡**（三个骑手负载率都在52.8%-59.5%）
- ✅ **分配最分散**（所有骑手都有任务）
- ✅ 优先处理紧急订单（按优先级排序）
- ✅ 综合考虑距离、时间、负载

**劣势：**
- ❌ 总距离最长（36.60km，比贪心算法多78.6%）
- ❌ 总时间最长（1.83小时，比贪心算法多471%）
- ❌ 总成本最高（219.61，比贪心算法多101.6%）
- ❌ 插入位置固定（路径末尾），灵活性较差

**适用场景：**
- 需要负载均衡的场景
- 所有骑手都需要有任务
- 订单有明确的优先级差异
- 对资源利用率要求高的场景

---

## 五、综合评估

### 性能排名（综合得分，越小越好）

1. **🥇 贪心插入算法** - 得分：**30.0**
   - 距离：最优（20.49km）
   - 时间：最优（0.32小时）
   - 成本：最优（108.90）
   - 负载均衡：较差

2. **🥈 最近邻算法** - 得分：**60.0**
   - 距离：中等（32.47km）
   - 时间：较差（1.62小时）
   - 成本：中等（194.83）
   - 负载均衡：较差

3. **🥉 优先级算法** - 得分：**70.0**
   - 距离：较差（36.60km）
   - 时间：最差（1.83小时）
   - 成本：最差（219.61）
   - 负载均衡：最优

---

## 六、详细数据对比

### 距离对比
```
贪心算法: 20.49km ████████████░░░░░░░░ (最优)
最近邻:   32.47km ████████████████████░░ (中等)
优先级:   36.60km ██████████████████████ (最长)
```

### 时间对比
```
贪心算法: 0.32小时 ██░░░░░░░░░░░░░░░░░░ (最快)
最近邻:   1.62小时 ████████████████░░░░ (中等)
优先级:   1.83小时 ████████████████████ (最慢)
```

### 成本对比
```
贪心算法: 108.90  ██████░░░░░░░░░░░░░░ (最低)
最近邻:   194.83  ████████████░░░░░░░░ (中等)
优先级:   219.61  ████████████████░░░░ (最高)
```

### 负载均衡对比
```
贪心算法: 不均衡  ████████████░░░░░░░░ (骑手1闲置)
最近邻:   不均衡  ████████████████░░░░ (骑手0满载)
优先级:   最均衡  ████████████████████ (所有骑手均衡)
```

---

## 七、算法选择建议

### 根据业务需求选择：

1. **追求最低成本** → 选择 **贪心插入算法**
   - 成本最低（108.90）
   - 距离最短（20.49km）
   - 时间最短（0.32小时）
   - 适合：成本敏感的场景

2. **追求负载均衡** → 选择 **优先级算法**
   - 负载最均衡（所有骑手都在52.8%-59.5%）
   - 所有骑手都有任务
   - 适合：需要充分利用资源的场景

3. **追求快速响应** → 选择 **最近邻算法**
   - 算法简单，计算速度快
   - 适合：订单量大，需要快速计算的场景

### 综合推荐：

**🏆 推荐使用：贪心插入算法**

**理由：**
1. 在所有性能指标上都是最优的
2. 成本比另外两种算法低44%-50%
3. 距离和时间都明显优于其他算法
4. 虽然负载不均衡，但在成本敏感的场景下，这是可以接受的

**改进建议：**
- 如果需要在保持性能的同时改善负载均衡，可以考虑：
  - 在贪心算法中加入负载均衡的惩罚项
  - 或者使用混合策略：先用贪心算法，再对结果进行负载均衡调整

---

## 八、结论

本次测试中，**贪心插入算法表现最优**，在距离、时间、成本三个核心指标上都明显优于其他两种算法。虽然存在负载不均衡的问题（骑手1完全闲置），但在追求最低成本的场景下，这是可以接受的权衡。

**优先级算法**在负载均衡方面表现最好，但代价是距离、时间和成本都显著增加。

**最近邻算法**在三个算法中表现中等，适合对计算速度要求高、对解质量要求不高的场景。


