# Android本地数据持久化综合实验报告

## 一、实验目的

通过本实验，掌握Android中三种常用的本地数据存储方式：

1. **文件（File）读写**：使用`FileInputStream`/`FileOutputStream`进行文本文件的保存与加载
2. **SharedPreferences**：使用`getSharedPreferences()`保存和读取简单的键值对配置数据
3. **SQLite数据库**：使用`SQLiteOpenHelper`管理数据库，完成基本的增删改查（CRUD）操作

## 二、实验环境

* **开发工具**：Android Studio 2023.1.1
* **开发语言**：Java
* **测试设备**：Android模拟器

## 三、实验内容与实现

### 3.1 应用架构设计

应用采用多Activity架构，包含以下主要组件：

| 组件名称 | 功能描述 |
| --- | --- |
| MainActivity | 主界面，提供文本编辑、文件读写和保存到数据库功能 |
| SettingsActivity | 设置界面，使用SharedPreferences保存用户配置 |
| RecordListActivity | 记录列表界面，显示SQLite数据库中的所有记录 |
| RecordDetailActivity | 记录详情界面，显示记录的完整内容 |
| RecordEditActivity | 记录编辑界面，支持修改已有记录 |

### 3.2 文件读写模块实现

#### 3.2.1 核心代码

    // 保存到文件
    private void saveToFile() {
        String text = contentEditText.getText().toString();
        try {
            FileOutputStream fos = openFileOutput(FILE_NAME, MODE_PRIVATE);
            fos.write(text.getBytes());
            fos.close();
            Toast.makeText(this, "保存成功", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            e.printStackTrace();
            Toast.makeText(this, "保存失败", Toast.LENGTH_SHORT).show();
        }
    }
    
    // 从文件加载
    private void loadFromFile() {
        try {
            FileInputStream fis = openFileInput(FILE_NAME);
            byte[] buffer = new byte[fis.available()];
            fis.read(buffer);
            fis.close();
    
            String text = new String(buffer);
            contentEditText.setText(text);
            Toast.makeText(this, "加载成功", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            e.printStackTrace();
            Toast.makeText(this, "文件不存在或读取失败", Toast.LENGTH_SHORT).show();
        }
    }

#### 3.2.2 功能特点

* 使用`openFileOutput()`和`openFileInput()`进行文件操作
* 文件存储在应用私有目录中，确保数据安全
* 完善的异常处理机制
* 用户友好的提示信息

### 3.3 SharedPreferences模块实现

#### 3.3.1 数据模型设计

| 键名  | 数据类型 | 默认值 | 描述  |
| --- | --- | --- | --- |
| auto_save | boolean | false | 是否自动保存 |
| user_name | string | ""  | 用户昵称 |
| passwd | string | ""  | 密码  |

#### 3.3.2 核心代码

    // 保存设置
    private void saveSettings() {
        SharedPreferences.Editor editor = prefs.edit();
        editor.putBoolean("auto_save", autoSaveCheckBox.isChecked());
        editor.putString("user_name", userNameEditText.getText().toString());
        editor.putString("passwd", passwordEditText.getText().toString());
        editor.apply();
    }
    
    // 加载设置
    private void loadSettings() {
        boolean autoSave = prefs.getBoolean("auto_save", false);
        String userName = prefs.getString("user_name", "");
        String password = prefs.getString("passwd", "");
    
        autoSaveCheckBox.setChecked(autoSave);
        userNameEditText.setText(userName);
        passwordEditText.setText(password);
    }
    
    // 自动保存功能
    @Override
    protected void onPause() {
        super.onPause();
        SharedPreferences prefs = getSharedPreferences(PREFS_NAME, MODE_PRIVATE);
        boolean autoSave = prefs.getBoolean("auto_save", false);
        if (autoSave) {
            saveToFile();
        }
    }

#### 3.3.3 功能特点

* 使用`getSharedPreferences()`获取实例
* 支持多种数据类型存储
* 自动保存功能根据用户设置触发
* 数据持久化，应用重启后仍可恢复

### 3.4 SQLite数据库模块实现

#### 3.4.1 数据库设计

**表名：** `records`

| 字段名 | 数据类型 | 约束  | 描述  |
| --- | --- | --- | --- |
| _id | INTEGER | PRIMARY KEY AUTOINCREMENT | 主键  |
| title | TEXT | NOT NULL | 标题  |
| content | TEXT | NOT NULL | 内容  |
| time | TEXT | NOT NULL | 创建时间 |

#### 3.4.2 DatabaseHelper类设计

    public class DatabaseHelper extends SQLiteOpenHelper {
        private static final String DATABASE_NAME = "notepad.db";
        private static final int DATABASE_VERSION = 1;
    
        // 数据库操作方法
        public long addRecord(Record record) { ... }
        public List<Record> getAllRecords() { ... }
        public Record getRecordById(int id) { ... }
        public int updateRecord(Record record) { ... }
        public void deleteRecord(int id) { ... }
    }

#### 3.4.3 数据操作实现

**1. 添加记录**

    public long addRecord(Record record) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(COLUMN_TITLE, record.getTitle());
        values.put(COLUMN_CONTENT, record.getContent());
        values.put(COLUMN_TIME, record.getTime());
    
        long id = db.insert(TABLE_RECORDS, null, values);
        db.close();
        return id;
    }

**2. 查询所有记录**

    public List<Record> getAllRecords() {
        List<Record> records = new ArrayList<>();
        SQLiteDatabase db = this.getReadableDatabase();
        String query = "SELECT * FROM " + TABLE_RECORDS + " ORDER BY " + COLUMN_TIME + " DESC";
        Cursor cursor = db.rawQuery(query, null);
    
        if (cursor.moveToFirst()) {
            do {
                Record record = new Record();
                record.setId(cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID)));
                record.setTitle(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_TITLE)));
                record.setContent(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_CONTENT)));
                record.setTime(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_TIME)));
                records.add(record);
            } while (cursor.moveToNext());
        }
        cursor.close();
        db.close();
        return records;
    }

**3. 更新记录**

    public int updateRecord(Record record) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(COLUMN_TITLE, record.getTitle());
        values.put(COLUMN_CONTENT, record.getContent());
        values.put(COLUMN_TIME, record.getTime());
    
        int result = db.update(TABLE_RECORDS, values, 
            COLUMN_ID + "=?", 
            new String[]{String.valueOf(record.getId())});
        db.close();
        return result;
    }

**4. 删除记录**

    public void deleteRecord(int id) {
        SQLiteDatabase db = this.getWritableDatabase();
        db.delete(TABLE_RECORDS, COLUMN_ID + "=?", new String[]{String.valueOf(id)});
        db.close();
    }

#### 3.4.4 功能特点

* 完整的CRUD操作实现
* 使用游标（Cursor）遍历查询结果
* 支持按时间倒序排列
* 数据库连接及时关闭，避免内存泄漏

## 四、界面设计与交互

### 4.1 主界面（MainActivity）

**布局文件：** `activity_main.xml`

**功能元素：**

1. 标题栏：显示当前登录用户
2. 菜单栏（标题右侧）：提供跳转到设置和记录列表的选项
3. 多行文本编辑框：用于输入和显示文本内容
4. 保存到文件按钮：将内容保存到本地文件
5. 从文件加载按钮：从本地文件读取内容
6. 保存为记录按钮：将内容保存到SQLite数据库

### 4.2 设置界面（SettingsActivity）

**布局文件：** `activity_settings.xml`

**功能元素：**

1. 自动保存复选框：控制是否启用自动保存
2. 用户名输入框：设置用户昵称
3. 密码输入框：设置密码
4. 保存设置按钮：保存当前配置
5. 登录按钮：保存设置并跳转到记录列表

### 4.3 记录列表界面（RecordListActivity）

**布局文件：** `activity_record_list.xml`

**功能特点：**

* 使用RecyclerView展示记录列表
* 支持下拉刷新（通过返回刷新实现）
* 长按记录弹出删除对话框
* 点击记录跳转到详情页面

### 4.4 记录详情界面（RecordDetailActivity）

**布局文件：** `activity_record_detail.xml`

**功能特点：**

* 完整显示记录标题、时间和内容
* 提供编辑和删除按钮
* 支持内容滚动查看

## 五、实验结果与分析

### 5.1 功能测试结果

| 功能模块 | 测试项目 | 测试结果 | 备注  |
| --- | --- | --- | --- |
| 文件读写 | 保存到文件 | ✓ 正常 | 文件保存在应用私有目录 |
| 文件读写 | 从文件加载 | ✓ 正常 | 文件不存在时有错误提示 |
| SharedPreferences | 保存设置 | ✓ 正常 | 重启应用后数据不丢失 |
| SharedPreferences | 自动保存 | ✓ 正常 | 根据设置自动触发保存 |
| SQLite数据库 | 添加记录 | ✓ 正常 | 支持自动生成ID和时间戳 |
| SQLite数据库 | 查询记录 | ✓ 正常 | 按时间倒序排列 |
| SQLite数据库 | 更新记录 | ✓ 正常 | 更新时间自动更新 |
| SQLite数据库 | 删除记录 | ✓ 正常 | 支持长按删除 |
| 用户界面 | 界面跳转 | ✓ 正常 | 所有界面跳转流畅 |
| 用户界面 | 数据绑定 | ✓ 正常 | 数据正确显示 |

## 六、实验总结

### 6.1 实验收获

通过本次实验，深入掌握了Android平台三种主要的数据持久化技术：

1. **文件读写**：学习了如何通过FileInputStream和FileOutputStream进行文件操作，理解了Android的文件系统结构和应用私有存储的概念。
  
2. **SharedPreferences**：掌握了轻量级数据存储方法，了解了其适用场景和局限性，学会了如何实现应用配置的持久化。
  
3. **SQLite数据库**：掌握了完整的数据库操作流程，包括数据库设计、创建、CRUD操作和结果处理，理解了数据库在Android应用中的重要作用。
  

### 6.2 改进方向

1. **功能扩展**
  
  * 添加搜索功能，支持按关键词查找记录
  * 支持记录分类和标签管理
  * 添加数据备份和恢复功能
2. **性能优化**
  
  * 实现分页加载，提高列表显示性能
  * 添加数据库索引，优化查询速度
  * 使用异步任务处理耗时操作
3. **用户体验**
  
  * 添加数据同步功能，支持多设备同步
  * 实现夜间模式切换
